* go笔记
1. escape analysis
   堆和栈，对于C/C++而言auto变量自然分配在栈上而如果需要分配在堆上则需要通过malloc调用来分配内存在
   堆上。而对于Go语言来讲编译时候会根据是否有外部引用来判断是否将内存分配在堆或者是栈上。
   [[http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast][Five things that make Go fast]]这篇文章里有详细的叙述。所以对于有些地方直接将类似与C/C++中的
   auto变量地址返回的这样的情景请不要惊讶。编译器已经考虑到了。
2. Sender close the channel
3. using recover() trapped the panic
4. format %T get the type
5. %q a single-quoted character literal safely escaped with Go syntax.
6. trace: GOMAXPROCS=2 GODEBUG=schedtrace=1000,scheddetail=1 ./trace
   https://www.goinggo.net/2015/02/scheduler-tracing-in-go.html for detail

* go code fix
  github.com\rogpeppe\godef\go\parser\parser.go

  // p.error(path.Pos(), fmt.Sprintf("cannot find identifier for package %q: %v", litToString(path), err))

  fixed this

* init vs main?
  Programs initialize and begin execution from the main package. If the main package imports other packages, they will be imported in the compile time. If one package is imported many times, it will be only compiled once. After importing packages, programs will initialize the constants and variables within the imported packages, then execute the init function if it exists, and so on. After all the other packages are initialized, programs will initialize constants and variables in the main package, then execute the init function inside the package if it exists. The following figure shows the process.
* dot import

  #+BEGIN_SRC bash
import(
    . "fmt"
)
#+END_SRC

The dot operator means you can omit the package name when you call functions inside of that package. Now `fmt.Printf("Hello world")` becomes to `Printf("Hello world")`.
* Assertion of Comma-ok pattern
#+BEGIN_SRC bash
if value, ok := element.(int); ok
#+END_SRC
* why golang's default ServeMux match "/notfound" path to "/"
the answer is in the pathMatch function.
* rob pike
  #+BEGIN_QUOTE
  Go is more about software engineering than programming language research. Or to rephrase, it is about language design in the service of software engineering.
  #+END_QUOTE
* make vs new?
Go有两个数据结构创建函数：new和make。两者的区别在学习Go语言的初期是一个常见的混淆点。基本的区别是`new(T)`返回一个`*T`，返回的这个指针可以被隐式地消除引用（图中的黑色箭头）。而`make(T, args)`返回一个普通的T。通常情况下，T内部有一些隐式的指针（图中的灰色箭头）。一句话，new返回一个指向已清零内存的指针，而make返回一个复杂的结构。
* continious stack
  方便goroutine的stack
* 网络api netpoll
On Linux, it uses epoll, on the BSDs and Darwin, it uses kqueue and on Windows it uses IoCompletionPort.
* build option
  -gcflags='-N -l'
  否则local变量会被优化掉不好调试。
* package命令规则
是单数，不是复数。
* http gzip response write
https://gist.github.com/the42/1956518
* pprof[fn:1]:
#+BEGIN_SRC go
package main

import (
  "fmt"
  "log"
  "net/http"
  _ "net/http/pprof" // here be dragons
)

func main() {
  http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello World!")
  })
  log.Fatal(http.ListenAndServe(":8080", nil))
}
#+END_SRC

url:
+ /debug/pprof/profile: 30-second CPU profile
+ /debug/pprof/heap: heap profile
+ /debug/pprof/goroutine?debug=1: all goroutines with stack traces
+ /debug/pprof/trace: take a trace
* http response body process:
Body不关闭，http客户端无法复用tcp连接，导致连接数上涨。需要做到两点：

#+BEGIN_SRC go
res, _ := client.Do(req)
io.Copy(ioutil.Discard, res.Body)
res.Body.Close()
#+END_SRC
即body应当被读取，然后关闭。

* gorm memleak:
gorm need rows.Close()

* interface in struct
https://stackoverflow.com/questions/24537443/meaning-of-a-struct-with-embedded-anonymous-interface

* Which declaration form should I use?
Use long declaration when you can’t know what data to store beforehand, otherwise, use short declaration. Use multiple declaration when you want to define multiple variables together or as an hint for code readability that the variables will be used together.

You can’t use short declarations outside of functions including main function. Or: you will meet with this error: “syntax error: non-declaration statement outside function body”.
* add line number for a log:
  log.SetFlags(log.LstdFlags | log.Lshortfile)
* 关于GMP之间的关系以及为什么引入P
   许多关于Go调度的上来就是给你GMP，但这里的展开我觉的讲的很好 https://news.ycombinator.com/item?id=12459841
   这个也不错， http://morsmachine.dk/go-scheduler

* go lang tool pprof
  tl,dr : [fn:2]
  #+BEGIN_SRC bash
  go get github.com/google/pprof
  #+END_SRC

  #+BEGIN_SRC go
  import (
  "runtime/pprof"
  )
  pprof.StartCPUProfile(os.Stdout)
  defer pprof.StopCPUProfile()
  #+END_SRC
  生成profile文件之后用tool来inspect：
  #+BEGIN_SRC bash
  go tool pprof cpu.profile
  #+END_SRC
  内存全量使用情况：
  go tool pprof -alloc_space http://localhost:6060/debug/pprof/heap
  当前情况使用：
  go tool pprof -inuse_space http://localhost:6060/debug/pprof/heap
  保存png文件:
  apt-get install graphviz
  go tool pprof -png http://localhost:6060/debug/pprof/heap > data.png
  如果是想知道CPU哪里慢了，用pprof
  看看goroutine情况的URL
  http://localhost:6060/debug/pprof/goroutine?debug=1
  跟着pprof的一个golang命令行工具：
  https://github.com/google/gops

* create reader from string?
#+BEGIN_SRC go
strings.NewReader(s)
#+END_SRC

* ssh connect方法：
github.com/rapidloop/rtop 这个repo里有相关方法，可以参考

* coredump的查看
还是用dlv工具[fn:3]

* go tool的一些参数
go build -x
看看过程都干了啥
go test -race
死锁检测
go get -d
只是clone不去安装
* grpc
编译proto：
protoc --go_out=plugins=grpc:. helloworld.proto
定义的proto会生成对应Client/Server的interface， 后面对应server的实现函数signature就需要和interface中指定的一样。
主要是stream这里需要理解一下，可以单向也可以全双工。通过获得stream然后对应读和写操作。
* 防止goroutine泄露
#+BEGIN_SRC go
  doWork := func(done <-chan interface{}, strchan <-chan string) <-chan interface{} {
    terminated := make(chan interface{})
    go func() {
      defer fmt.Println("doWork exited.")
      defer close(terminated)
      for {
        select {
        case s := <-strchan:
          fmt.Println(s)
        // add this to prevent goroutine leak
        case <-done:
          return
        }
      }
    }()
    return terminated
  }
#+END_SRC

  一般都会添加一个done channel用来退出，不妨称为done channel pattern吧。

* fetch go value type?
reflect.TypeOf(s)
reflect.ValueOf(s).Kind()
fmt.Printf("%T\n", s)
* https://research.swtch.com/interfaces
  interface internel

* Footnotes

[fn:1] http://mmcloughlin.com/posts/your-pprof-is-showing

[fn:2] http://www.integralist.co.uk/posts/profiling-go/

[fn:3] https://rakyll.org/coredumps/
