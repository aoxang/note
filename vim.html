<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>vim简介</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="vim简介"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-05-25 Fri"/>
<meta name="author" content="ry"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">vim简介</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 简介</a></li>
<li><a href="#sec-2">2 移动</a></li>
<li><a href="#sec-3">3 编辑上下文</a></li>
<li><a href="#sec-4">4 复制粘贴</a></li>
<li><a href="#sec-5">5 查找/替换/删除</a></li>
<li><a href="#sec-6">6 宏与脚本</a></li>
<li><a href="#sec-7">7 保存</a></li>
<li><a href="#sec-8">8 结语</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 简介</h2>
<div class="outline-text-2" id="text-1">

<p>  设想这样一种场景，一个人才思泉涌，他打开某个编辑器，一气呵成，没有任何的删除与跳转，然后凭借这个杰作拿到诺贝尔，显然这样的人用Notepad/Emacs/Vim效果都是一样。（Vim还要慢一些，因为初始状态为Normal模式）所以，我想说的是软件有它的应用场景。Vim也不例外。Vim就是让你能够快速的进行移动/删除/替换等编辑行为。
</p>
<p>  
  行为与输入正文的区分，和真相一样，键盘也只有一个，怎样区分你想输入的是告诉Vim的行为还是输入的正文？Vim引入了模式之分，简言之，在一个模式下你的键盘输入会当作命令，这个模式官方名称为Normal模式，对应的就是Insert模式，在这个模式之中的所有键盘输入都会被当作文本的追加。怎样在两者之间进行切换？ <i>ESC</i> 进入Normal模式， 进入Insert模式有很多，最基本是 <i>i</i> 。下文会详细叙述。你也可以做这样一种想象，Normal模式让好像是在编辑内容上盖了一层透明薄膜，你的输入都是最先被这层薄膜截获，并对应某种行为，这种行为的结果要么是改变当前光标的位置，为你的输入作准备，要么是改变了你所编辑的文本内容。
</p>
<p>
  <b>接口与实现</b> 这是IT里不厌其繁所讲到的，这里不涉及到编程语言的API，我想说的是不论VIM也好Emacs也好其实都只是实现不同而已，那接口在哪里？在你的大脑中，你的意念就是接口，说白了不论你是VIMer也好Emacser也好，首先你下手之前已经在你的大脑里有某种Intent，只是下手之时键盘映射不一样而已。当然这里我忽略了局限性，即软件的差异固然会造成你思考的某种方式的差异性。你在用某种软件时相辅相成的相互作用的过程。所以下文对vim的介绍都是以Intent和Vim键映射这样的列表展开。
</p>
<p>
  <b>编辑文本的组成</b> 从小到大，字符/单词/句子/段落/文件。
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 移动</h2>
<div class="outline-text-2" id="text-2">

<p>  鉴于你我都不是之前那个拿诺贝尔的人，所以编辑过程中不可避免的要移动光标，这个时候，各个编辑器的差距就全出来了。一般Vim的介绍文章上来就是 <i>hjkl</i> ，我决定按移动步伐从小到大的顺序来介绍。见下表：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Intent</th><th scope="col" class="left">Vim key map</th><th scope="col" class="left"></th><th scope="col" class="left"></th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">左移/右移一个字符</td><td class="left"><i>h</i> <i>l</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">以单词顺序移动向后/向前/一个单词</td><td class="left"><i>w</i> <i>b</i> <i>e</i> (e将光标置于单词尾部）</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">以空格为区分的下一个element</td><td class="left"><i>W</i> <i>B</i> <i>E</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">上一行/下一行</td><td class="left"><i>j</i> <i>k</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">上一句/下一句</td><td class="left"><i>(</i> <i>)</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">上一段/下一段</td><td class="left"><i>{</i> <i>}</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">当前显示内容的head/middle/bottom</td><td class="left"><i>H</i> <i>M</i> <i>L</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">当前显示内容从顶端数第三行</td><td class="left"><i>3H</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">当前显示内容从底端倒数第三行</td><td class="left"><i>3L</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">翻页，文件尾部方向/头部方向翻页</td><td class="left"><i>&lt;c-f&gt;</i> <i>&lt;c-b&gt;</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">到文件顶端</td><td class="left"><i>gg</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">到文件末端</td><td class="left"><i>G</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">直到你编辑的是另外一个文件，打开另一个文件</td><td class="left"><i>:e anotherfile.txt</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>


<p>
  顺便唠叨一句，不要用方向键来使用vim或者emacs，因为我始终认为这样做的人没有领略到任何一个编辑器的精髓：让你手不离开主键盘区去做任何编辑的事情（emacs要把编辑两字去掉更适合）。翻页我只列出了两个，其实还有翻半页，翻一行。这些应用的不是很多，所以就没有列出来，
  精确定位，除了上表的移动外，vim还可以精确的定位到某一行，甚至行内定位到某一个字符，下表详细说明
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>移动步伐由小到大的VIM键盘映射。</caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Intent</th><th scope="col" class="left">Vim Key Map</th><th scope="col" class="left"></th><th scope="col" class="left"></th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">到文本的50%处</td><td class="left"><i>50%</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">到文本的30行</td><td class="left"><i>30G</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">从当前光标出开始往行尾方向找到第一个字符a处</td><td class="left"><i>fa</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">继续？</td><td class="left"><i>;</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">从当前光标开始往行首方向找到第一个字符a处</td><td class="left"><i>Fa</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">继续？</td><td class="left">,</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>



<p>
至此，移动光标的步伐介绍大致如此，其实许多时候我都是用 <i>f</i>, <i>&lt;c-f&gt;&lt;c-b&gt;</i>, <i>HML</i> 配合 <i>jk</i> 来实现文档内的快速定位。虽然看起来两个表格列在这里看过跟没看过没多大差别，但真正你完完全全领略到上面所有键组合的威力你就会领略到vim的强大。
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 编辑上下文</h2>
<div class="outline-text-2" id="text-3">

<p>  这是我认为Vim最为强大的地方，我认为Vim在这方面丝毫不逊于emacs。所谓编辑上下文，就是你处在编辑的一个过程当中，你所需要做的下一个步骤Vim都有帮你做键盘映射。没有任何动鼠标的意念。
</p><blockquote>

<p>时空局部性原理&ndash;计算机程序从时间和空间都表现出“局部性”：<br/>
时间的局部性（Temporal Locality）：最近被访问的内存内容（指令或数据）很快还会被访问；<br/>
空间的局部性（Spatial Locality）：靠近当前正在被访问内存的内存内容很快也会被访问。<br/>
&ndash;《计算机体系结构量化研究方法》
</p>
</blockquote>


<p>
  同样我觉得编辑过程也存在这种局部性原理。下面的列表就是从局部性出发，设想你在一个编辑环境中所能做的事情。
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Intent</th><th scope="col" class="left">Vim Key Map</th><th scope="col" class="left"></th><th scope="col" class="left"></th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">到行首</td><td class="left"><i>0</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">到行尾</td><td class="left"><i>$</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">在行首添加内容</td><td class="left"><i>I</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">在行尾添加内容</td><td class="left"><i>A</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标所在的行</td><td class="left"><i>dd</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标到行尾的内容</td><td class="left"><i>d$</i> <i>D</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标所在的行并且在这行位置添加新内容</td><td class="left"><i>S</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标所在位置到行尾内容并且置Vim为Insert模式待输入正文</td><td class="left"><i>C</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">复制当前行</td><td class="left"><i>yy</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">粘贴到光标之后/之前</td><td class="left"><i>p</i> <i>P</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标所在的字符</td><td class="left"><i>x</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标所在的单词</td><td class="left"><i>dw</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除光标所在的单词及后一个单词</td><td class="left"><i>d2w</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">删除单词并置vim为Insert模式</td><td class="left"><i>cw</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">将一个字符替换为另一个字符如s</td><td class="left"><i>rs</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">将后续输入替换当前内容，不改变vim模式</td><td class="left"><i>R</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">改变字符的大小写</td><td class="left"><i>~</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">连接2行</td><td class="left"><i>J</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">重复执行上一次命令一次</td><td class="left"><i>.</i></td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>


<p>
我平时用到的就这么多了。
</p>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 复制粘贴</h2>
<div class="outline-text-2" id="text-4">

<p>  前面已经有提到过 <i>yy</i> <i>p</i> <i>P</i> 。这里补充的是对复制的内容的选择和将内容写到vim寄存器中的方法。
  在Normal模式下按 <i>v</i> 键会进入之前没有提及的模式，visual模式，这个模式用来选中文本用以删除或是复制。按 <i>v</i> 键后用移动光标的快捷键后会选中按 <i>v</i> 之前光标所在位置到当前光标位置的内容，然后可以用过 <i>y</i> 来复制，或者 <i>d</i> 来删除。如果想分别粘贴不同的内容就需要将不同的内容保存起来了。可以通过vim寄存器来实现，vim默认的10个寄存器，寄存器名为0~9 会按时间顺序保存删除或者是复制的内容，但我记不住哪个里面放什么内容，所以，通常都是显示的将一个内容放入指定的寄存器中，操作也简单，在之前所有复制粘贴操作之前加 /"寄存器名/ 即可。比如 /"ayy/ 复制当前行到寄存器a中， /"ap/ 粘贴a中的内容到光标后。
</p>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 查找/替换/删除</h2>
<div class="outline-text-2" id="text-5">

<p>  查找和替换主要有以下几种方法
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Intent</th><th scope="col" class="left">Vim Key Map</th><th scope="col" class="left"></th><th scope="col" class="left"></th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">从光标当前位置向文件尾方向查找某关键字</td><td class="left">/keyword</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">从管表当前位置向文件头方向查找某关键字</td><td class="left">?keyword</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">查询光标当前位置的单词（往文件尾方向）</td><td class="left">#</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">全文替换每行出现的第一个单词</td><td class="left">:s/one/two/</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">全文替换全部</td><td class="left">:s/one/two/g</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">区间替换 第一行到第20行之间</td><td class="left">:1,20s/one/two/</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">替换内容含有'/'这个字符可以这样方便一些</td><td class="left">:s#/one#/home#g</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">区间替换 当前行至下三行</td><td class="left">:.,+3s/one/two/</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">全文正则删除带关键字的行</td><td class="left">:g/one/d</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">带关键字的行全部搬到文件尾</td><td class="left">:g/one/m$</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">将文本倒序</td><td class="left">:g/^/m0</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">保留带关键字的行，其余删除</td><td class="left">:g!/one/d</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 宏与脚本</h2>
<div class="outline-text-2" id="text-6">

<p>  宏是对机械化编辑的一种固化，就像脚本是一坨命令一样，宏也是一坨命令，不过是vim命令。
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>查找替换</caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Intent</th><th scope="col" class="left">vim key map</th><th scope="col" class="left"></th><th scope="col" class="left"></th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">如何录制宏</td><td class="left">qayourlogichereq a是宏的名字 开始和结束都是q作标记。</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">如何执行宏</td><td class="left">@a</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>

  个人不推荐宏，当编辑文本行数为10000+时，宏的速度和sed的速度不可同日而语，还是用sed吧。

</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 保存</h2>
<div class="outline-text-2" id="text-7">

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>宏</caption>
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">Intent</th><th scope="col" class="left">Vim key map</th><th scope="col" class="left"></th><th scope="col" class="left"></th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">保存</td><td class="left">:w</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">另存为</td><td class="left">:w another.txt</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">追加到某文件尾部</td><td class="left">:w &gt;&gt; another.txt</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
<tr><td class="left">保存文件某一部分</td><td class="left">:1,20w another.txt</td><td class="left"></td><td class="left"></td><td class="left"></td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 结语</h2>
<div class="outline-text-2" id="text-8">

<p>  六年vim的使用总结，就这么几张表，可是当所有命令组合起来时确实有时候有一种行云流水般的感觉，当然自己也不是什么vim控，比如这篇文章就是在emacs下编辑，虽然emacs用的比较丑。
</p>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-05-25 Fri</p>
<p class="author">Author: ry</p>
<p class="creator">Org version 7.8.11 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
