* Linux kernel development重读笔记
**  ch02 overview
     编译kernel:
     #+BEGIN_SRC bash


     make menuconfig
     make defconfig
     # 每次编译之前必敲：
     make oldconfig
     make时只想关注错误信息
     make > /dev/null
     #+END_SRC
** ch03进程管理

    OS提供两个抽象:
    #+BEGIN_QUOTE
    A virtualized processor and virtual memory. The virtual processor gives the process the illusion that is alone monopolizes the system, despite possibly sharing the processor among hundreds of other processes. Virtual memory let the process allocate and manage memory as if it alone owned all the momory in the system.
    #+END_QUOTE

    需要注意的是Linux的threads共享share memory的抽象，但是每个线程都各自拥有虚拟化的processor。

    进程始于fork()终于exit()。

    kernel stack的大小：一般是page的2倍。即stack在32位上为8KB，64位上为16KB

    Unix 特点：
    + simple， system call非常少
    + everything is a file
    + written in C
    + fast process creation time
    + robust IPC


    build kernel
    #+BEGIN_SRC bash
    make defconfig # defaults for your architecture
    #+END_SRC

    kernel characteristics
    + The kernel has access to neither the C library nor the standard C headers.
    + The kernel is coded in GNU C.
    + The kernel lacks the memory protection afforded to user-space.
    + The kernel cannot easily execute floating-point operations.
    + The kernel has a small per-process fixed-size stack.
    + Because the kernel has asynchronous interrupts, is preemptive, and supports SMP,
    + synchronization and concurrency are major concerns within the kernel.
    + Portability is important.

* process
  Each thread includes a unique program counter, process stack, and set of processor registers.

  调度对象： The kernel schedules individual threads, not processes.

  current宏得到当前进程的kernel空间，这个结构体中保存了指向task_struct的指针。
#+BEGIN_SRC c
static __always_inline struct task_struct *get_current(void)
{
  return this_cpu_read_stable(current_task);
}
#+END_SRC
linkage什么意思？

    首先作为linux操作系统,它不一定就只运行在X86平台下面,还有其他平台例如ARM,PPC，
达芬奇等等，所以在不同的处理器结构上不能保证都是通过 局部栈传递参数的，可能此时就有朋
友就会问：不放在栈中能放在哪里呢？熟悉ARM的朋友一定知道ARM对函数调用过程中的传参定义
了一套规则，叫 ATPCS（内地叫AAPCS），规则中明确指出ARM中R0-R4都是作为通用寄存器使
用，在函数调用时处理器从R0-R4中获取参数，在函数返回时再 将需要返回的参数一次存到R0-
R4中，也就是说可以将函数参数直接存放在寄存器中，所以为了严格区别函数参数的存放位置，
引入了两个标记，即 asmlinkage和FASTCALL，前者表示将函数参数存放在局部栈中,后者则
是通知编译器将函数参数用寄存器保存起来


** 调度
    调度的策略决定总体上OS的感觉：

    The scheduler policy in Unix systems tends to explicitly favor
I/O-bound processes, thus providing good process response time. Linux,
aiming to provide good interactive response and desktop performance,
 optimizes for process response (low latency), thus favoring I/O-bound
 processes over processor-bound processors.As we will see, this is done
 in a creative manner that does not neglect processor-bound processes.

 进程有两个不交叉的属性，nice值和实时优先级，nice值越高优先级越低，而实时优先级相反，
Linux implements real-time priorities in accordance with the relevant
 Unix standards, specifically POSIX.1b.

 sched chain:
 #+BEGIN_SRC c
 #define SCHED_NORMAL   0
 #define SCHED_FIFO    1
 #define SCHED_RR    2
 #define SCHED_BATCH   3
 /* SCHED_ISO: reserved but not implemented yet */
 #define SCHED_IDLE    5
 #define SCHED_DEADLINE    6
 #+END_SRC

 四种类型的调度器：
 1. stop_sched_class:
    The stop_sched_class is to stop cpu, using on SMP system, for
load balancing and cpu hotplug. This class have the highest scheduling priority.

If your system does not define CONFIG_SMP, you can try to remove
this class, there are several files need to be changed for successful
compilation.

 2. rt_sched_class
 3. fair_sched_class
 4. idle_sched_class
